"""
Calculs avancés d'astrologie
Progressions, révolutions solaires, lunaires, etc.
"""

import math
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
from .constants import *
from .utils import *
from .ephemeris import EphemerisCalculator


class AdvancedAstrologyCalculator:
    """Calculateur pour les techniques avancées d'astrologie"""
    
    def __init__(self):
        self.ephemeris = EphemerisCalculator()
    
    def calculate_secondary_progressions(self, natal_chart: Dict, 
                                       progression_date: datetime) -> Dict:
        """
        Calcule les progressions secondaires (symboliques)
        Une journée après la naissance = une année de vie
        """
        birth_date = natal_chart['birth_data']['date']
        
        # Calculer l'âge en années
        age_years = (progression_date - birth_date).days / 365.25
        
        # Calculer la date de progression (jour de naissance + age en jours)
        progression_days = int(age_years * 365.25)
        progression_internal_date = birth_date + timedelta(days=progression_days)
        
        # Calculer les positions progressées
        birth_lat = natal_chart['birth_data']['latitude']
        birth_lon = natal_chart['birth_data']['longitude']
        birth_tz = natal_chart['birth_data']['timezone']
        
        progressed_positions = self.ephemeris.calculate_all_planets(
            self._datetime_to_julian(progression_internal_date, birth_tz)
        )
        
        # Calculer les aspects entre progressé et natal
        progressed_aspects = self._calculate_progression_aspects(
            progressed_positions, 
            natal_chart['planet_positions']
        )
        
        # Calculer les angles de progressions
        progressed_angles = self._calculate_progressed_angles(
            natal_chart, 
            progression_internal_date
        )
        
        return {
            'progression_date': progression_date,
            'internal_date': progression_internal_date,
            'age_years': age_years,
            'progressed_positions': progressed_positions,
            'aspects_to_natal': progressed_aspects,
            'progressed_angles': progressed_angles,
            'interpretations': self._interpret_progressions(
                progressed_positions, 
                progressed_aspects, 
                age_years
            )
        }
    
    def calculate_solar_return(self, natal_chart: Dict, 
                             return_year: int) -> Dict:
        """
        Calcule la révolution solaire (anniversaire solaire)
        Le moment exact où le Soleil revient à sa position natale
        """
        natal_sun_longitude = natal_chart['planet_positions']['Sun']['longitude']
        birth_date = natal_chart['birth_data']['date']
        
        # Trouver la date de l'anniversaire solaire
        solar_return_date = self._find_solar_return_date(
            natal_sun_longitude, 
            return_year, 
            birth_date
        )
        
        # Calculer le thème de révolution solaire
        return_lat = natal_chart['birth_data']['latitude']  # ou lieu de résidence
        return_lon = natal_chart['birth_data']['longitude']
        return_tz = natal_chart['birth_data']['timezone']
        
        solar_return_chart = self._calculate_chart_for_date(
            solar_return_date,
            return_lat,
            return_lon,
            return_tz
        )
        
        # Comparer avec le thème natal
        solar_return_analysis = self._analyze_solar_return(
            natal_chart,
            solar_return_chart
        )
        
        return {
            'return_year': return_year,
            'return_date': solar_return_date,
            'return_chart': solar_return_chart,
            'analysis': solar_return_analysis,
            'interpretations': self._interpret_solar_return(
                solar_return_analysis,
                return_year
            )
        }
    
    def calculate_lunar_return(self, natal_chart: Dict, 
                             return_month: int) -> Dict:
        """
        Calcule la révolution lunaire (retour lunaire)
        Le moment où la Lune revient à sa position natale (tous les ~28 jours)
        """
        natal_moon_longitude = natal_chart['planet_positions']['Moon']['longitude']
        birth_date = natal_chart['birth_data']['date']
        
        # Trouver la date du retour lunaire
        lunar_return_date = self._find_lunar_return_date(
            natal_moon_longitude,
            return_month,
            birth_date
        )
        
        # Calculer le thème de retour lunaire
        return_lat = natal_chart['birth_data']['latitude']
        return_lon = natal_chart['birth_data']['longitude']
        return_tz = natal_chart['birth_data']['timezone']
        
        lunar_return_chart = self._calculate_chart_for_date(
            lunar_return_date,
            return_lat,
            return_lon,
            return_tz
        )
        
        # Analyser le retour lunaire
        lunar_analysis = self._analyze_lunar_return(
            natal_chart,
            lunar_return_chart
        )
        
        return {
            'return_month': return_month,
            'return_date': lunar_return_date,
            'return_chart': lunar_return_chart,
            'analysis': lunar_analysis,
            'interpretations': self._interpret_lunar_return(lunar_analysis)
        }
    
    def calculate_planetary_returns(self, natal_chart: Dict, 
                                  planet: str, 
                                  return_number: int) -> Dict:
        """
        Calcule les retours planétaires (Saturne, Jupiter, etc.)
        """
        if planet not in natal_chart['planet_positions']:
            raise ValueError(f"Planète {planet} non trouvée dans le thème natal")
        
        natal_planet_longitude = natal_chart['planet_positions'][planet]['longitude']
        birth_date = natal_chart['birth_data']['date']
        
        # Trouver la date du retour planétaire
        return_date = self._find_planetary_return_date(
            natal_planet_longitude,
            planet,
            return_number,
            birth_date
        )
        
        # Calculer le thème de retour
        return_lat = natal_chart['birth_data']['latitude']
        return_lon = natal_chart['birth_data']['longitude']
        return_tz = natal_chart['birth_data']['timezone']
        
        return_chart = self._calculate_chart_for_date(
            return_date,
            return_lat,
            return_lon,
            return_tz
        )
        
        # Analyser le retour
        return_analysis = self._analyze_planetary_return(
            natal_chart,
            return_chart,
            planet
        )
        
        return {
            'planet': planet,
            'return_number': return_number,
            'return_date': return_date,
            'return_chart': return_chart,
            'analysis': return_analysis,
            'interpretations': self._interpret_planetary_return(
                return_analysis,
                planet,
                return_number
            )
        }
    
    def calculate_tertiary_progressions(self, natal_chart: Dict, 
                                      progression_date: datetime) -> Dict:
        """
        Calcule les progressions tertiaires
        Une journée après la naissance = un mois de vie
        """
        birth_date = natal_chart['birth_data']['date']
        
        # Calculer l'âge en mois
        age_months = (progression_date - birth_date).days / 30.44
        
        # Calculer la date de progression (jour de naissance + age en jours)
        progression_days = int(age_months)
        progression_internal_date = birth_date + timedelta(days=progression_days)
        
        # Calculer les positions progressées
        birth_lat = natal_chart['birth_data']['latitude']
        birth_lon = natal_chart['birth_data']['longitude']
        birth_tz = natal_chart['birth_data']['timezone']
        
        progressed_positions = self.ephemeris.calculate_all_planets(
            self._datetime_to_julian(progression_internal_date, birth_tz)
        )
        
        return {
            'progression_date': progression_date,
            'internal_date': progression_internal_date,
            'age_months': age_months,
            'progressed_positions': progressed_positions,
            'interpretations': self._interpret_tertiary_progressions(
                progressed_positions,
                age_months
            )
        }
    
    def calculate_minor_progressions(self, natal_chart: Dict, 
                                   progression_date: datetime) -> Dict:
        """
        Calcule les progressions mineures (progressions solunaires)
        13 lunaisons = 1 année
        """
        birth_date = natal_chart['birth_data']['date']
        
        # Calculer le nombre de lunaisons
        days_diff = (progression_date - birth_date).days
        lunar_months = days_diff / 27.32166  # Période sidérale de la lune
        
        # Calculer la date de progression
        progression_days = int(lunar_months * 27.32166)
        progression_internal_date = birth_date + timedelta(days=progression_days)
        
        # Calculer les positions
        birth_lat = natal_chart['birth_data']['latitude']
        birth_lon = natal_chart['birth_data']['longitude']
        birth_tz = natal_chart['birth_data']['timezone']
        
        progressed_positions = self.ephemeris.calculate_all_planets(
            self._datetime_to_julian(progression_internal_date, birth_tz)
        )
        
        return {
            'progression_date': progression_date,
            'internal_date': progression_internal_date,
            'lunar_months': lunar_months,
            'progressed_positions': progressed_positions,
            'interpretations': self._interpret_minor_progressions(
                progressed_positions,
                lunar_months
            )
        }
    
    def calculate_midpoints(self, chart_data: Dict) -> Dict:
        """
        Calcule les midpoints (points médians) entre planètes
        Technique utilisée en astrologie moderne
        """
        positions = chart_data['planet_positions']
        midpoints = []
        
        planets = list(positions.keys())
        
        for i, planet1 in enumerate(planets):
            for j, planet2 in enumerate(planets[i+1:], i+1):
                pos1 = positions[planet1]['longitude']
                pos2 = positions[planet2]['longitude']
                
                # Calculer le midpoint (avec correction pour les angles > 180°)
                if abs(pos1 - pos2) > 180:
                    # Prendre le chemin le plus court
                    if pos1 > pos2:
                        midpoint = ((pos1 + pos2 + 360) / 2) % 360
                    else:
                        midpoint = ((pos1 + pos2) / 2) % 360
                else:
                    midpoint = (pos1 + pos2) / 2
                
                sign_index = int(midpoint // 30)
                sign_name = ZODIAC_SIGNS[sign_index]
                
                midpoints.append({
                    'planets': [planet1, planet2],
                    'longitude': midpoint,
                    'sign': sign_name,
                    'interpretation': f"Point médian entre {planet1} et {planet2}"
                })
        
        # Trier par longitude
        midpoints.sort(key=lambda x: x['longitude'])
        
        return {
            'midpoints': midpoints,
            'interpretations': self._interpret_midpoints(midpoints)
        }
    
    def calculate_harmonic_chart(self, natal_chart: Dict, harmonic: int) -> Dict:
        """
        Calcule un thème harmonique
        Technique avancée qui multiplie toutes les positions par un nombre harmonique
        """
        if harmonic < 1:
            raise ValueError("L'harmonique doit être >= 1")
        
        harmonic_positions = {}
        
        for planet, data in natal_chart['planet_positions'].items():
            natal_longitude = data['longitude']
            
            # Calculer la position harmonique
            harmonic_longitude = (natal_longitude * harmonic) % 360
            
            harmonic_positions[planet] = {
                'longitude': harmonic_longitude,
                'harmonic': harmonic,
                'natal_position': natal_longitude,
                'sign': ZODIAC_SIGNS[int(harmonic_longitude // 30)]
            }
        
        # Calculer les aspects dans le thème harmonique
        harmonic_aspects = self._calculate_harmonic_aspects(harmonic_positions)
        
        return {
            'harmonic': harmonic,
            'positions': harmonic_positions,
            'aspects': harmonic_aspects,
            'interpretations': self._interpret_harmonic_chart(
                harmonic_positions,
                harmonic_aspects,
                harmonic
            )
        }
    
    def calculate_composite_chart(self, chart1: Dict, chart2: Dict) -> Dict:
        """
        Calcule un thème composite (pour la synastrie)
        Moyenne des positions entre deux thèmes
        """
        composite_positions = {}
        
        # Utiliser la liste des planètes du premier thème
        planets = list(chart1['planet_positions'].keys())
        
        for planet in planets:
            if planet in chart2['planet_positions']:
                pos1 = chart1['planet_positions'][planet]['longitude']
                pos2 = chart2['planet_positions'][planet]['longitude']
                
                # Calculer le point médian (avec correction pour les angles)
                if abs(pos1 - pos2) > 180:
                    # Prendre le chemin le plus court
                    if pos1 > pos2:
                        composite_pos = ((pos1 + pos2 + 360) / 2) % 360
                    else:
                        composite_pos = ((pos1 + pos2) / 2) % 360
                else:
                    composite_pos = (pos1 + pos2) / 2
                
                composite_positions[planet] = {
                    'longitude': composite_pos,
                    'component1': pos1,
                    'component2': pos2,
                    'sign': ZODIAC_SIGNS[int(composite_pos // 30)]
                }
        
        # Calculer les aspects dans le composite
        composite_aspects = self._calculate_composite_aspects(composite_positions)
        
        return {
            'composite_positions': composite_positions,
            'aspects': composite_aspects,
            'interpretations': self._interpret_composite_chart(
                composite_positions,
                composite_aspects
            )
        }
    
    # Méthodes utilitaires privées
    
    def _datetime_to_julian(self, dt: datetime, timezone: str) -> float:
        """Convertit datetime en jour julien"""
        import pytz
        tz = pytz.timezone(timezone)
        dt_tz = tz.localize(dt)
        
        return julian_day(dt_tz.year, dt_tz.month, dt_tz.day,
                         dt_tz.hour + dt_tz.minute/60 + dt_tz.second/3600)
    
    def _find_solar_return_date(self, natal_sun_longitude: float, 
                               year: int, birth_date: datetime) -> datetime:
        """Trouve la date exacte du retour solaire pour une année donnée"""
        # Commencer par l'anniversaire approximatif
        approx_date = datetime(year, birth_date.month, birth_date.day,
                              birth_date.hour, birth_date.minute)
        
        # Chercher la date exacte avec une précision de 1 minute
        best_date = approx_date
        min_difference = float('inf')
        
        # Chercher dans un intervalle de ±7 jours
        for day_offset in range(-7, 8):
            test_date = approx_date + timedelta(days=day_offset)
            
            # Tester différentes heures
            for hour in range(24):
                for minute in range(0, 60, 30):  # Pas de 30 minutes
                    test_datetime = test_date.replace(hour=hour, minute=minute)
                    
                    # Calculer la position du Soleil
                    jd = self._datetime_to_julian(test_datetime, birth_date.strftime('%Z'))
                    sun_pos = self.ephemeris.calculate_planet_position('Sun', jd)
                    
                    # Calculer la différence
                    difference = abs(sun_pos['longitude'] - natal_sun_longitude)
                    if difference > 180:
                        difference = 360 - difference
                    
                    if difference < min_difference:
                        min_difference = difference
                        best_date = test_datetime
        
        return best_date
    
    def _find_lunar_return_date(self, natal_moon_longitude: float,
                              month_number: int, birth_date: datetime) -> datetime:
        """Trouve la date du retour lunaire pour un mois donné"""
        # Estimer la période (environ 27.3 jours par lunaison)
        lunar_period = 27.32166
        days_offset = month_number * lunar_period
        
        approx_date = birth_date + timedelta(days=int(days_offset))
        
        # Chercher la date exacte
        best_date = approx_date
        min_difference = float('inf')
        
        # Chercher dans un intervalle de ±3 jours
        for day_offset in range(-3, 4):
            test_date = approx_date + timedelta(days=day_offset)
            
            for hour in range(24):
                test_datetime = test_date.replace(hour=hour, minute=0)
                
                # Calculer la position de la Lune
                jd = self._datetime_to_julian(test_datetime, birth_date.strftime('%Z'))
                moon_pos = self.ephemeris.calculate_planet_position('Moon', jd)
                
                # Calculer la différence
                difference = abs(moon_pos['longitude'] - natal_moon_longitude)
                if difference > 180:
                    difference = 360 - difference
                
                if difference < min_difference:
                    min_difference = difference
                    best_date = test_datetime
        
        return best_date
    
    def _find_planetary_return_date(self, natal_longitude: float,
                                  planet: str, return_number: int,
                                  birth_date: datetime) -> datetime:
        """Trouve la date du retour planétaire"""
        # Périodes moyennes des planètes (en années)
        planetary_periods = {
            'Mercury': 0.24,
            'Venus': 0.62,
            'Mars': 1.88,
            'Jupiter': 11.86,
            'Saturn': 29.46,
            'Uranus': 84.01,
            'Neptune': 164.8,
            'Pluto': 248.0
        }
        
        period = planetary_periods.get(planet, 1.0)
        years_offset = return_number * period
        
        approx_date = birth_date.replace(year=birth_date.year + int(years_offset))
        
        # Chercher la date exacte
        best_date = approx_date
        min_difference = float('inf')
        
        # Chercher dans un intervalle de ±30 jours
        for day_offset in range(-30, 31):
            test_date = approx_date + timedelta(days=day_offset)
            
            for hour in range(24):
                test_datetime = test_date.replace(hour=hour, minute=0)
                
                # Calculer la position de la planète
                jd = self._datetime_to_julian(test_datetime, birth_date.strftime('%Z'))
                planet_pos = self.ephemeris.calculate_planet_position(planet, jd)
                
                # Calculer la différence
                difference = abs(planet_pos['longitude'] - natal_longitude)
                if difference > 180:
                    difference = 360 - difference
                
                if difference < min_difference:
                    min_difference = difference
                    best_date = test_datetime
        
        return best_date
    
    def _calculate_progression_aspects(self, progressed_positions: Dict, 
                                     natal_positions: Dict) -> List[Dict]:
        """Calcule les aspects entre les positions progressées et natales"""
        aspects = []
        
        for prog_planet, prog_data in progressed_positions.items():
            for natal_planet, natal_data in natal_positions.items():
                if prog_planet == natal_planet:
                    continue  # Éviter les aspects d'une planète avec elle-même
                
                prog_long = prog_data['longitude']
                natal_long = natal_data['longitude']
                
                # Calculer la distance
                distance = abs(prog_long - natal_long)
                if distance > 180:
                    distance = 360 - distance
                
                # Vérifier les aspects
                for aspect_def in ASPECTS:
                    aspect_angle = aspect_def['angle']
                    aspect_orb = aspect_def['orb']
                    
                    orb = abs(distance - aspect_angle)
                    
                    if orb <= aspect_orb:
                        aspects.append({
                            'progressed_planet': prog_planet,
                            'natal_planet': natal_planet,
                            'aspect': aspect_def['name'],
                            'orb': orb,
                            'applying': self._is_applying(prog_data, natal_data)
                        })
        
        # Trier par orb
        aspects.sort(key=lambda x: x['orb'])
        
        return aspects
    
    def _calculate_progressed_angles(self, natal_chart: Dict, 
                                   progression_date: datetime) -> Dict:
        """Calcule les angles progressés (simplifié)"""
        # Pour une version complète, ceci nécessiterait des calculs complexes
        # Cette version est une approximation
        
        natal_ascendant = natal_chart['house_data']['ascendant']
        natal_mc = natal_chart['house_data']['mc']
        
        # Approximation : les angles progressent d'environ 1° par an
        years_since_birth = (progression_date - natal_chart['birth_data']['date']).days / 365.25
        
        progressed_ascendant = (natal_ascendant + years_since_birth) % 360
        progressed_mc = (natal_mc + years_since_birth) % 360
        
        return {
            'progressed_ascendant': progressed_ascendant,
            'progressed_mc': progressed_mc,
            'progression_rate': 1.0  # Degrés par an
        }
    
    def _analyze_solar_return(self, natal_chart: Dict, 
                            solar_return_chart: Dict) -> Dict:
        """Analyse la révolution solaire par rapport au thème natal"""
        analysis = {
            'house emphasis': {},
            'planetary_strength': {},
            'angular_planets': [],
            'prominent_aspects': []
        }
        
        # Analyser l'emphase par maison
        house_counts = {}
        for planet, data in solar_return_chart['planet_positions'].items():
            house = solar_return_chart['planet_houses'][planet]
            house_counts[house] = house_counts.get(house, 0) + 1
        
        analysis['house_emphasis'] = dict(sorted(house_counts.items(), 
                                                 key=lambda x: x[1], reverse=True))
        
        # Trouver les planètes angulaires (proches des angles)
        angles = {
            'ascendant': solar_return_chart['house_data']['ascendant'],
            'mc': solar_return_chart['house_data']['mc'],
            'descendant': solar_return_chart['house_data']['descendant'],
            'ic': solar_return_chart['house_data']['ic']
        }
        
        angular_planets = []
        for planet, data in solar_return_chart['planet_positions'].items():
            planet_long = data['longitude']
            
            for angle_name, angle_long in angles.items():
                distance = abs(planet_long - angle_long)
                if distance > 180:
                    distance = 360 - distance
                
                if distance <= 10:  # Orb de 10° pour les angles
                    angular_planets.append({
                        'planet': planet,
                        'angle': angle_name,
                        'distance': distance
                    })
        
        analysis['angular_planets'] = sorted(angular_planets, 
                                           key=lambda x: x['distance'])
        
        return analysis
    
    def _analyze_lunar_return(self, natal_chart: Dict, 
                            lunar_return_chart: Dict) -> Dict:
        """Analyse le retour lunaire"""
        analysis = {
            'lunar_house': lunar_return_chart['planet_houses']['Moon'],
            'lunar_sign': get_zodiac_sign(
                lunar_return_chart['planet_positions']['Moon']['longitude']
            )[1],
            'aspects_to_natal': [],
            'emotional_focus': ''
        }
        
        # Aspects de la Lune progressée au thème natal
        lunar_long = lunar_return_chart['planet_positions']['Moon']['longitude']
        
        for natal_planet, natal_data in natal_chart['planet_positions'].items():
            natal_long = natal_data['longitude']
            
            distance = abs(lunar_long - natal_long)
            if distance > 180:
                distance = 360 - distance
            
            for aspect_def in ASPECTS:
                if aspect_def['type'] == 'majeur':  # Seulement les aspects majeurs
                    orb = abs(distance - aspect_def['angle'])
                    if orb <= aspect_def['orb']:
                        analysis['aspects_to_natal'].append({
                            'lunar_aspect': aspect_def['name'],
                            'natal_planet': natal_planet,
                            'orb': orb
                        })
        
        # Déterminer le focus émotionnel
        lunar_house = analysis['lunar_house']
        house_meanings = {
            1: "identité personnelle",
            2: "valeurs et ressources",
            3: "communication quotidienne",
            4: "foyer et émotions profondes",
            5: "créativité et plaisir",
            6: "travail et routine",
            7: "relations et partenariats",
            8: "transformation partagée",
            9: "expansion et apprentissage",
            10: "carrière et responsabilités",
            11: "amis et projets futurs",
            12: "inconscient et spiritualité"
        }
        
        analysis['emotional_focus'] = house_meanings.get(lunar_house, "domaine de vie")
        
        return analysis
    
    def _analyze_planetary_return(self, natal_chart: Dict, 
                                return_chart: Dict, 
                                planet: str) -> Dict:
        """Analyse le retour planétaire"""
        analysis = {
            'return_house': return_chart['planet_houses'][planet],
            'return_sign': get_zodiac_sign(
                return_chart['planet_positions'][planet]['longitude']
            )[1],
            'cycle_phase': '',
            'aspects_to_natal': []
        }
        
        # Déterminer la phase du cycle
        natal_long = natal_chart['planet_positions'][planet]['longitude']
        return_long = return_chart['planet_positions'][planet]['longitude']
        
        # Calculer la progression du cycle
        cycle_progress = (return_long - natal_long) % 360
        
        if cycle_progress < 90:
            analysis['cycle_phase'] = 'croissant'
        elif cycle_progress < 180:
            analysis['cycle_phase'] = 'premier quartier'
        elif cycle_progress < 270:
            analysis['cycle_phase'] = 'décroissant'
        else:
            analysis['cycle_phase'] = 'dernier quartier'
        
        # Aspects du retour au natal
        for natal_planet, natal_data in natal_chart['planet_positions'].items():
            if natal_planet == planet:
                continue
            
            natal_long = natal_data['longitude']
            
            distance = abs(return_long - natal_long)
            if distance > 180:
                distance = 360 - distance
            
            for aspect_def in ASPECTS:
                orb = abs(distance - aspect_def['angle'])
                if orb <= aspect_def['orb']:
                    analysis['aspects_to_natal'].append({
                        'aspect': aspect_def['name'],
                        'natal_planet': natal_planet,
                        'orb': orb
                    })
        
        return analysis
    
    def _calculate_harmonic_aspects(self, harmonic_positions: Dict) -> List[Dict]:
        """Calcule les aspects dans un thème harmonique"""
        aspects = []
        
        planets = list(harmonic_positions.keys())
        
        for i, planet1 in enumerate(planets):
            for j, planet2 in enumerate(planets[i+1:], i+1):
                pos1 = harmonic_positions[planet1]['longitude']
                pos2 = harmonic_positions[planet2]['longitude']
                
                distance = abs(pos1 - pos2)
                if distance > 180:
                    distance = 360 - distance
                
                # Vérifier les aspects
                for aspect_def in ASPECTS:
                    orb = abs(distance - aspect_def['angle'])
                    if orb <= aspect_def['orb']:
                        aspects.append({
                            'planet1': planet1,
                            'planet2': planet2,
                            'aspect': aspect_def['name'],
                            'orb': orb,
                            'type': aspect_def['type']
                        })
        
        return aspects
    
    def _calculate_composite_aspects(self, composite_positions: Dict) -> List[Dict]:
        """Calcule les aspects dans un thème composite"""
        # Même logique que les aspects normaux
        return self._calculate_harmonic_aspects(composite_positions)
    
    # Méthodes d'interprétation
    
    def _interpret_progressions(self, progressed_positions: Dict, 
                              progressed_aspects: List[Dict], 
                              age_years: float) -> Dict:
        """Interprète les progressions"""
        interpretations = {
            'summary': f"Progressions pour l'âge de {age_years:.1f} ans",
            'major_themes': [],
            'timing': []
        }
        
        # Analyser les aspects majeurs
        major_aspects = [a for a in progressed_aspects if a['type'] == 'majeur' and a['orb'] < 3]
        
        if major_aspects:
            interpretations['major_themes'].append(
                f"Période importante avec {len(major_aspects)} aspects majeurs actifs"
            )
        
        # Analyser les planètes qui changent de signe
        # (Ceci nécessiterait de stocker les positions natales pour comparaison)
        
        return interpretations
    
    def _interpret_solar_return(self, solar_return_analysis: Dict, year: int) -> Dict:
        """Interprète la révolution solaire"""
        interpretations = {
            'year': year,
            'themes': [],
            'advice': []
        }
        
        # Analyser l'emphase par maison
        if solar_return_analysis.get('house_emphasis'):
            top_house = max(solar_return_analysis['house_emphasis'].items(), 
                           key=lambda x: x[1])
            interpretations['themes'].append(
                f"Accent mis sur la maison {top_house[0]} de votre thème"
            )
        
        # Analyser les planètes angulaires
        if solar_return_analysis.get('angular_planets'):
            angular_count = len(solar_return_analysis['angular_planets'])
            interpretations['themes'].append(
                f"{angular_count} planètes angulaires - année d'action et de visibilité"
            )
        
        return interpretations
    
    def _interpret_lunar_return(self, lunar_analysis: Dict) -> Dict:
        """Interprète le retour lunaire"""
        interpretations = {
            'emotional_focus': lunar_analysis['emotional_focus'],
            'monthly_themes': [],
            'mood': ''
        }
        
        # Analyser le signe lunaire
        lunar_sign = lunar_analysis['lunar_sign']
        interpretations['mood'] = f"Humeur dominante : influence {lunar_sign}"
        
        # Analyser les aspects
        if lunar_analysis['aspects_to_natal']:
            interpretations['monthly_themes'].append(
                f"{len(lunar_analysis['aspects_to_natal'])} aspects actifs avec votre thème natal"
            )
        
        return interpretations
    
    def _interpret_planetary_return(self, return_analysis: Dict, 
                                  planet: str, return_number: int) -> Dict:
        """Interprète un retour planétaire"""
        interpretations = {
            'cycle_theme': '',
            'life_area': '',
            'maturity': return_number
        }
        
        # Thèmes selon la planète
        planet_themes = {
            'Mercury': 'communication, apprentissage, échanges',
            'Venus': 'amour, valeurs, créativité',
            'Mars': 'énergie, action, conflits',
            'Jupiter': 'croissance, opportunités, foi',
            'Saturne': 'responsabilités, leçons, structure',
            'Uranus': 'changement, liberté, innovation',
            'Neptune': 'spiritualité, rêves, confusion',
            'Pluto': 'transformation, pouvoir, régénération'
        }
        
        interpretations['cycle_theme'] = planet_themes.get(planet, 'développement personnel')
        
        # Domaine de vie selon la maison
        house = return_analysis['return_house']
        life_areas = {
            1: 'identité et apparence',
            2: 'finances et valeurs',
            3: 'communication quotidienne',
            4: 'foyer et famille',
            5: 'créativité et romance',
            6: 'travail et santé',
            7: 'relations et partenariats',
            8: 'transformation partagée',
            9: 'philosophie et voyages',
            10: 'carrière et réputation',
            11: 'amis et projets',
            12: 'spiritualité et subconscient'
        }
        
        interpretations['life_area'] = life_areas.get(house, 'vie personnelle')
        
        return interpretations
    
    def _interpret_tertiary_progressions(self, progressed_positions: Dict, 
                                       age_months: float) -> Dict:
        """Interprète les progressions tertiaires"""
        return {
            'summary': f"Progressions tertiaires pour {age_months:.1f} mois",
            'development_stage': 'croissance rapide' if age_months < 12 else 'consolidation'
        }
    
    def _interpret_minor_progressions(self, progressed_positions: Dict, 
                                    lunar_months: float) -> Dict:
        """Interprète les progressions mineures"""
        return {
            'summary': f"Progressions mineures pour {lunar_months:.1f} mois lunaires",
            'emotional_cycle': 'phase active' if lunar_months % 2 < 1 else 'phase réflexive'
        }
    
    def _interpret_midpoints(self, midpoints: List[Dict]) -> Dict:
        """Interprète les midpoints"""
        interpretations = {
            'integration_themes': [],
            'synthesis_points': len(midpoints)
        }
        
        if midpoints:
            interpretations['integration_themes'].append(
                f"{len(midpoints)} points de synthèse entre énergies planétaires"
            )
        
        return interpretations
    
    def _interpret_harmonic_chart(self, harmonic_positions: Dict, 
                                harmonic_aspects: List[Dict], 
                                harmonic: int) -> Dict:
        """Interprète un thème harmonique"""
        return {
            'harmonic_number': harmonic,
            'vibration': f"fréquence {harmonic}x",
            'themes': f"résonances harmoniques de niveau {harmonic}"
        }
    
    def _interpret_composite_chart(self, composite_positions: Dict, 
                                 composite_aspects: List[Dict]) -> Dict:
        """Interprète un thème composite"""
        return {
            'relationship_energy': 'synthèse entre deux personnalités',
            'shared_themes': f"{len(composite_aspects)} aspects de relation",
            'integration_level': 'moyenne énergétique'
        }


class AdvancedCalculationsGUI:
    """Interface graphique pour les calculs avancés"""
    
    def __init__(self, calculator: AdvancedAstrologyCalculator):
        self.calculator = calculator
    
    def create_progressions_panel(self, natal_chart: Dict) -> Dict:
        """Crée un panneau d'interface pour les progressions"""
        return {
            'secondary_progressions': self._create_secondary_progressions_ui(natal_chart),
            'tertiary_progressions': self._create_tertiary_progressions_ui(natal_chart),
            'minor_progressions': self._create_minor_progressions_ui(natal_chart)
        }
    
    def create_returns_panel(self, natal_chart: Dict) -> Dict:
        """Crée un panneau d'interface pour les retours"""
        return {
            'solar_return': self._create_solar_return_ui(natal_chart),
            'lunar_return': self._create_lunar_return_ui(natal_chart),
            'planetary_returns': self._create_planetary_returns_ui(natal_chart)
        }
    
    def _create_secondary_progressions_ui(self, natal_chart: Dict):
        """Crée l'interface pour les progressions secondaires"""
        current_date = datetime.now()
        
        # Calculer les progressions pour aujourd'hui
        progressions = self.calculator.calculate_secondary_progressions(
            natal_chart, current_date
        )
        
        return {
            'current_progressions': progressions,
            'age': progressions['age_years'],
            'key_aspects': self._extract_key_progression_aspects(progressions),
            'interpretations': progressions['interpretations']
        }
    
    def _extract_key_progression_aspects(self, progressions: Dict) -> List[Dict]:
        """Extrait les aspects de progression les plus importants"""
        aspects = progressions.get('aspects_to_natal', [])
        
        # Filtrer les aspects majeurs avec petit orb
        key_aspects = [
            asp for asp in aspects 
            if asp['type'] == 'majeur' and asp['orb'] < 2.0
        ]
        
        return key_aspects[:5]  # Top 5
    
    def _create_solar_return_ui(self, natal_chart: Dict):
        """Crée l'interface pour les révolutions solaires"""
        current_year = datetime.now().year
        
        solar_return = self.calculator.calculate_solar_return(
            natal_chart, current_year
        )
        
        return {
            'current_return': solar_return,
            'return_date': solar_return['return_date'],
            'year_themes': solar_return['interpretations'],
            'house_emphasis': solar_return['analysis']['house_emphasis'],
            'angular_planets': solar_return['analysis']['angular_planets'][:3]
        }
    
    def create_advanced_analysis_report(self, natal_chart: Dict) -> str:
        """Génère un rapport d'analyse avancée"""
        report = []
        
        # Progressions
        current_date = datetime.now()
        progressions = self.calculator.calculate_secondary_progressions(
            natal_chart, current_date
        )
        
        report.append("ANALYSE DES PROGRESSIONS")
        report.append("=" * 50)
        report.append(f"Âge actuel: {progressions['age_years']:.1f} ans")
        report.append(f"Date de progression: {progressions['internal_date']}")
        
        # Aspects progressés importants
        if progressions['aspects_to_natal']:
            major_aspects = [a for a in progressions['aspects_to_natal'] 
                           if a['orb'] < 2]
            if major_aspects:
                report.append(f"\nAspects progressés majeurs ({len(major_aspects)}):")
                for aspect in major_aspects[:3]:
                    report.append(f"  - {aspect['progressed_planet']} "
                                f"{aspect['aspect']} {aspect['natal_planet']} "
                                f"(orb: {aspect['orb']:.1f}°)")
        
        # Révolution solaire actuelle
        current_year = datetime.now().year
        solar_return = self.calculator.calculate_solar_return(natal_chart, current_year)
        
        report.append(f"\nRÉVOLUTION SOLAIRE {current_year}")
        report.append("=" * 30)
        report.append(f"Date du retour: {solar_return['return_date']}")
        
        if solar_return['analysis']['house_emphasis']:
            top_house = max(solar_return['analysis']['house_emphasis'].items(), 
                           key=lambda x: x[1])
            report.append(f"Maison la plus sollicitée: Maison {top_house[0]} "
                         f"({top_house[1]} planètes)")
        
        if solar_return['analysis']['angular_planets']:
            report.append(f"\nPlanètes angulaires: "
                         f"{len(solar_return['analysis']['angular_planets'])}")
        
        return "\n".join(report)