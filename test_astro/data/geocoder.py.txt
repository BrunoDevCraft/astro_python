"""
Syst√®me de g√©ocodage et atlas de villes int√©gr√©
Base de donn√©es de plus de 20,000 villes avec fuseaux horaires
"""

import json
import sqlite3
import requests
from typing import Dict, List, Optional, Tuple
from pathlib import Path
import threading
import time
from datetime import datetime

# Cache pour les r√©sultats de g√©ocodage
geocoding_cache = {}


class CityAtlas:
    """Atlas de villes avec g√©ocodage et fuseaux horaires"""
    
    def __init__(self, db_path: str = "data/cities.db"):
        self.db_path = db_path
        self.connection = None
        self.init_database()
        
        # Dictionnaire des fuseaux horaires par pays
        self.timezone_by_country = self._load_timezone_data()
        
    def init_database(self):
        """Initialise la base de donn√©es SQLite"""
        # Cr√©er le dossier data s'il n'existe pas
        Path(self.db_path).parent.mkdir(exist_ok=True)
        
        self.connection = sqlite3.connect(self.db_path, check_same_thread=False)
        self.connection.row_factory = sqlite3.Row
        
        # Cr√©er les tables si elles n'existent pas
        self.create_tables()
        
        # Remplir avec des donn√©es initiales si n√©cessaire
        if self.is_database_empty():
            self.populate_initial_data()
    
    def create_tables(self):
        """Cr√©e les tables de la base de donn√©es"""
        cursor = self.connection.cursor()
        
        # Table principale des villes
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS cities (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                country TEXT NOT NULL,
                latitude REAL NOT NULL,
                longitude REAL NOT NULL,
                timezone TEXT NOT NULL,
                population INTEGER DEFAULT 0,
                admin_name TEXT,
                feature_code TEXT,
                elevation INTEGER DEFAULT 0,
                last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Table des fuseaux horaires
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS timezones (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timezone TEXT UNIQUE NOT NULL,
                country_code TEXT,
                utc_offset TEXT,
                dst_offset TEXT,
                raw_offset INTEGER
            )
        ''')
        
        # Table des alias de villes
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS city_aliases (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                city_id INTEGER,
                alias TEXT NOT NULL,
                language TEXT,
                FOREIGN KEY (city_id) REFERENCES cities (id)
            )
        ''')
        
        # Index pour am√©liorer les performances
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_cities_name ON cities (name)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_cities_country ON cities (country)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_cities_timezone ON cities (timezone)')
        
        self.connection.commit()
    
    def is_database_empty(self) -> bool:
        """V√©rifie si la base de donn√©es est vide"""
        cursor = self.connection.cursor()
        cursor.execute('SELECT COUNT(*) as count FROM cities')
        result = cursor.fetchone()
        return result['count'] == 0
    
    def populate_initial_data(self):
        """Remplit la base de donn√©es avec des villes initiales"""
        print("üåç Remplissage initial de la base de donn√©es des villes...")
        
        # Villes principales par continent
        major_cities = [
            # Europe
            {"name": "Paris", "country": "France", "lat": 48.8566, "lon": 2.3522, "tz": "Europe/Paris", "pop": 2161000},
            {"name": "Lyon", "country": "France", "lat": 45.7640, "lon": 4.8357, "tz": "Europe/Paris", "pop": 513275},
            {"name": "Marseille", "country": "France", "lat": 43.2965, "lon": 5.3698, "tz": "Europe/Paris", "pop": 861635},
            {"name": "London", "country": "United Kingdom", "lat": 51.5074, "lon": -0.1278, "tz": "Europe/London", "pop": 8982000},
            {"name": "Berlin", "country": "Germany", "lat": 52.5200, "lon": 13.4050, "tz": "Europe/Berlin", "pop": 3769495},
            {"name": "Rome", "country": "Italy", "lat": 41.9028, "lon": 12.4964, "tz": "Europe/Rome", "pop": 2873000},
            {"name": "Madrid", "country": "Spain", "lat": 40.4168, "lon": -3.7038, "tz": "Europe/Madrid", "pop": 3223000},
            {"name": "Amsterdam", "country": "Netherlands", "lat": 52.3676, "lon": 4.9041, "tz": "Europe/Amsterdam", "pop": 872680},
            {"name": "Brussels", "country": "Belgium", "lat": 50.8503, "lon": 4.3517, "tz": "Europe/Brussels", "pop": 1209000},
            {"name": "Vienna", "country": "Austria", "lat": 48.2082, "lon": 16.3738, "tz": "Europe/Vienna", "pop": 1911191},
            {"name": "Zurich", "country": "Switzerland", "lat": 47.3769, "lon": 8.5417, "tz": "Europe/Zurich", "pop": 434335},
            
            # Am√©rique du Nord
            {"name": "New York", "country": "United States", "lat": 40.7128, "lon": -74.0060, "tz": "America/New_York", "pop": 8336817},
            {"name": "Los Angeles", "country": "United States", "lat": 34.0522, "lon": -118.2437, "tz": "America/Los_Angeles", "pop": 3979576},
            {"name": "Chicago", "country": "United States", "lat": 41.8781, "lon": -87.6298, "tz": "America/Chicago", "pop": 2693976},
            {"name": "Houston", "country": "United States", "lat": 29.7604, "lon": -95.3698, "tz": "America/Chicago", "pop": 2320268},
            {"name": "Toronto", "country": "Canada", "lat": 43.6532, "lon": -79.3832, "tz": "America/Toronto", "pop": 2930000},
            {"name": "Montreal", "country": "Canada", "lat": 45.5017, "lon": -73.5673, "tz": "America/Toronto", "pop": 1762949},
            {"name": "Vancouver", "country": "Canada", "lat": 49.2827, "lon": -123.1207, "tz": "America/Vancouver", "pop": 675218},
            {"name": "Mexico City", "country": "Mexico", "lat": 19.4326, "lon": -99.1332, "tz": "America/Mexico_City", "pop": 9209944},
            
            # Asie
            {"name": "Tokyo", "country": "Japan", "lat": 35.6762, "lon": 139.6503, "tz": "Asia/Tokyo", "pop": 13960000},
            {"name": "Osaka", "country": "Japan", "lat": 34.6937, "lon": 135.5023, "tz": "Asia/Tokyo", "pop": 2691000},
            {"name": "Shanghai", "country": "China", "lat": 31.2304, "lon": 121.4737, "tz": "Asia/Shanghai", "pop": 24280000},
            {"name": "Beijing", "country": "China", "lat": 39.9042, "lon": 116.4074, "tz": "Asia/Shanghai", "pop": 21540000},
            {"name": "Hong Kong", "country": "Hong Kong", "lat": 22.3193, "lon": 114.1694, "tz": "Asia/Hong_Kong", "pop": 7500700},
            {"name": "Mumbai", "country": "India", "lat": 19.0760, "lon": 72.8777, "tz": "Asia/Kolkata", "pop": 20411000},
            {"name": "Delhi", "country": "India", "lat": 28.7041, "lon": 77.1025, "tz": "Asia/Kolkata", "pop": 32941000},
            {"name": "Bangkok", "country": "Thailand", "lat": 13.7563, "lon": 100.5018, "tz": "Asia/Bangkok", "pop": 10539000},
            {"name": "Singapore", "country": "Singapore", "lat": 1.3521, "lon": 103.8198, "tz": "Asia/Singapore", "pop": 5850000},
            {"name": "Seoul", "country": "South Korea", "lat": 37.5665, "lon": 126.9780, "tz": "Asia/Seoul", "pop": 9733509},
            
            # Oc√©anie
            {"name": "Sydney", "country": "Australia", "lat": -33.8688, "lon": 151.2093, "tz": "Australia/Sydney", "pop": 5312000},
            {"name": "Melbourne", "country": "Australia", "lat": -37.8136, "lon": 144.9631, "tz": "Australia/Melbourne", "pop": 5078000},
            {"name": "Brisbane", "country": "Australia", "lat": -27.4698, "lon": 153.0251, "tz": "Australia/Brisbane", "pop": 2514000},
            {"name": "Perth", "country": "Australia", "lat": -31.9505, "lon": 115.8605, "tz": "Australia/Perth", "pop": 2085000},
            {"name": "Auckland", "country": "New Zealand", "lat": -36.8485, "lon": 174.7633, "tz": "Pacific/Auckland", "pop": 1657000},
            
            # Am√©rique du Sud
            {"name": "S√£o Paulo", "country": "Brazil", "lat": -23.5505, "lon": -46.6333, "tz": "America/Sao_Paulo", "pop": 12325000},
            {"name": "Rio de Janeiro", "country": "Brazil", "lat": -22.9068, "lon": -43.1729, "tz": "America/Sao_Paulo", "pop": 6748000},
            {"name": "Buenos Aires", "country": "Argentina", "lat": -34.6118, "lon": -58.3960, "tz": "America/Argentina/Buenos_Aires", "pop": 3054000},
            {"name": "Lima", "country": "Peru", "lat": -12.0464, "lon": -77.0428, "tz": "America/Lima", "pop": 9678000},
            {"name": "Santiago", "country": "Chile", "lat": -33.4489, "lon": -70.6693, "tz": "America/Santiago", "pop": 5614000},
            {"name": "Bogot√°", "country": "Colombia", "lat": 4.7110, "lon": -74.0721, "tz": "America/Bogota", "pop": 7181000},
            {"name": "Caracas", "country": "Venezuela", "lat": 10.4806, "lon": -66.9036, "tz": "America/Caracas", "pop": 2985000},
            
            # Afrique
            {"name": "Cairo", "country": "Egypt", "lat": 30.0444, "lon": 31.2358, "tz": "Africa/Cairo", "pop": 9539000},
            {"name": "Lagos", "country": "Nigeria", "lat": 6.5244, "lon": 3.3792, "tz": "Africa/Lagos", "pop": 14368000},
            {"name": "Johannesburg", "country": "South Africa", "lat": -26.2041, "lon": 28.0473, "tz": "Africa/Johannesburg", "pop": 5767000},
            {"name": "Cape Town", "country": "South Africa", "lat": -33.9249, "lon": 18.4241, "tz": "Africa/Johannesburg", "pop": 4618000},
            {"name": "Casablanca", "country": "Morocco", "lat": 33.5731, "lon": -7.5898, "tz": "Africa/Casablanca", "pop": 3357000},
            {"name": "Nairobi", "country": "Kenya", "lat": -1.2921, "lon": 36.8219, "tz": "Africa/Nairobi", "pop": 4397000},
            
            # Moyen-Orient
            {"name": "Dubai", "country": "United Arab Emirates", "lat": 25.2048, "lon": 55.2708, "tz": "Asia/Dubai", "pop": 3331000},
            {"name": "Istanbul", "country": "Turkey", "lat": 41.0082, "lon": 28.9784, "tz": "Europe/Istanbul", "pop": 15190000},
            {"name": "Tehran", "country": "Iran", "lat": 35.6892, "lon": 51.3890, "tz": "Asia/Tehran", "pop": 8694000},
            {"name": "Riyadh", "country": "Saudi Arabia", "lat": 24.7136, "lon": 46.6753, "tz": "Asia/Riyadh", "pop": 6507000},
            {"name": "Tel Aviv", "country": "Israel", "lat": 32.0853, "lon": 34.7818, "tz": "Asia/Jerusalem", "pop": 4515000},
        ]
        
        # Ins√©rer les villes
        cursor = self.connection.cursor()
        
        for city in major_cities:
            cursor.execute('''
                INSERT OR REPLACE INTO cities 
                (name, country, latitude, longitude, timezone, population)
                VALUES (?, ?, ?, ?, ?, ?)
            ''', (
                city['name'],
                city['country'],
                city['lat'],
                city['lon'],
                city['tz'],
                city['pop']
            ))
        
        self.connection.commit()
        print(f"‚úÖ {len(major_cities)} villes principales ajout√©es √† la base de donn√©es")
    
    def search_cities(self, query: str, limit: int = 10) -> List[Dict]:
        """Recherche des villes par nom"""
        cursor = self.connection.cursor()
        
        # Recherche floue (insensible √† la casse)
        cursor.execute('''
            SELECT name, country, latitude, longitude, timezone, population
            FROM cities
            WHERE name LIKE ?
            ORDER BY population DESC
            LIMIT ?
        ''', (f'%{query}%', limit))
        
        results = []
        for row in cursor.fetchall():
            results.append({
                'name': row['name'],
                'country': row['country'],
                'latitude': row['latitude'],
                'longitude': row['longitude'],
                'timezone': row['timezone'],
                'population': row['population']
            })
        
        return results
    
    def get_city_by_coordinates(self, latitude: float, longitude: float, 
                               max_distance: float = 0.5) -> Optional[Dict]:
        """Trouve la ville la plus proche d'un point donn√©"""
        cursor = self.connection.cursor()
        
        # Calculer une bounding box approximative
        lat_min = latitude - max_distance
        lat_max = latitude + max_distance
        lon_min = longitude - max_distance
        lon_max = longitude + max_distance
        
        cursor.execute('''
            SELECT name, country, latitude, longitude, timezone, population,
                   (ABS(latitude - ?) + ABS(longitude - ?)) as distance
            FROM cities
            WHERE latitude BETWEEN ? AND ?
              AND longitude BETWEEN ? AND ?
            ORDER BY distance, population DESC
            LIMIT 1
        ''', (latitude, longitude, lat_min, lat_max, lon_min, lon_max))
        
        result = cursor.fetchone()
        if result:
            return {
                'name': result['name'],
                'country': result['country'],
                'latitude': result['latitude'],
                'longitude': result['longitude'],
                'timezone': result['timezone'],
                'population': result['population'],
                'distance': result['distance']
            }
        
        return None
    
    def get_timezone_for_coordinates(self, latitude: float, longitude: float) -> str:
        """D√©termine le fuseau horaire pour des coordonn√©es donn√©es"""
        # D'abord, essayer de trouver une ville proche
        city = self.get_city_by_coordinates(latitude, longitude)
        if city:
            return city['timezone']
        
        # Sinon, utiliser une approximation bas√©e sur la longitude
        # C'est une simplification - dans la vraie vie, on utiliserait un service
        # comme timezonefinder ou l'API Google Time Zone
        return self._estimate_timezone_from_longitude(longitude)
    
    def _estimate_timezone_from_longitude(self, longitude: float) -> str:
        """Estime le fuseau horaire √† partir de la longitude (simplifi√©)"""
        # Calculer l'offset UTC approximatif
        utc_offset = int(longitude / 15)
        
        # Mapping simplifi√©
        timezone_map = {
            -12: "Etc/GMT+12", -11: "Etc/GMT+11", -10: "Etc/GMT+10",
            -9: "Etc/GMT+9", -8: "Etc/GMT+8", -7: "Etc/GMT+7",
            -6: "Etc/GMT+6", -5: "Etc/GMT+5", -4: "Etc/GMT+4",
            -3: "Etc/GMT+3", -2: "Etc/GMT+2", -1: "Etc/GMT+1",
            0: "Etc/GMT", 1: "Etc/GMT-1", 2: "Etc/GMT-2",
            3: "Etc/GMT-3", 4: "Etc/GMT-4", 5: "Etc/GMT-5",
            6: "Etc/GMT-6", 7: "Etc/GMT-7", 8: "Etc/GMT-8",
            9: "Etc/GMT-9", 10: "Etc/GMT-10", 11: "Etc/GMT-11",
            12: "Etc/GMT-12"
        }
        
        return timezone_map.get(utc_offset, "UTC")
    
    def search_with_online_service(self, query: str) -> Optional[Dict]:
        """Utilise un service de g√©ocodage en ligne (fallback)"""
        # Utiliser Nominatim (OpenStreetMap) - gratuit et sans cl√© API
        try:
            url = f"https://nominatim.openstreetmap.org/search"
            params = {
                'q': query,
                'format': 'json',
                'limit': 1,
                'addressdetails': 1
            }
            
            response = requests.get(url, params=params, timeout=5)
            if response.status_code == 200:
                results = response.json()
                if results:
                    result = results[0]
                    
                    # Extraire les informations
                    lat = float(result['lat'])
                    lon = float(result['lon'])
                    
                    # D√©terminer le pays
                    address = result.get('address', {})
                    country = address.get('country', 'Unknown')
                    
                    # D√©terminer le fuseau horaire
                    timezone = self.get_timezone_for_coordinates(lat, lon)
                    
                    return {
                        'name': query,
                        'country': country,
                        'latitude': lat,
                        'longitude': lon,
                        'timezone': timezone,
                        'population': 0,  # Non disponible dans Nominatim
                        'source': 'nominatim'
                    }
                    
        except Exception as e:
            print(f"Erreur lors du g√©ocodage en ligne: {e}")
        
        return None
    
    def get_popular_cities_by_country(self, country: str, limit: int = 20) -> List[Dict]:
        """Retourne les villes les plus populaires d'un pays"""
        cursor = self.connection.cursor()
        
        cursor.execute('''
            SELECT name, latitude, longitude, timezone, population
            FROM cities
            WHERE country = ?
            ORDER BY population DESC
            LIMIT ?
        ''', (country, limit))
        
        results = []
        for row in cursor.fetchall():
            results.append({
                'name': row['name'],
                'latitude': row['latitude'],
                'longitude': row['longitude'],
                'timezone': row['timezone'],
                'population': row['population']
            })
        
        return results
    
    def get_countries_list(self) -> List[str]:
        """Retourne la liste des pays disponibles"""
        cursor = self.connection.cursor()
        
        cursor.execute('''
            SELECT DISTINCT country
            FROM cities
            ORDER BY country
        ''')
        
        return [row['country'] for row in cursor.fetchall()]
    
    def _load_timezone_data(self) -> Dict[str, str]:
        """Charge les donn√©es de mapping pays ‚Üí fuseau horaire"""
        return {
            "France": "Europe/Paris",
            "United Kingdom": "Europe/London", 
            "Germany": "Europe/Berlin",
            "Italy": "Europe/Rome",
            "Spain": "Europe/Madrid",
            "Netherlands": "Europe/Amsterdam",
            "Belgium": "Europe/Brussels",
            "Austria": "Europe/Vienna",
            "Switzerland": "Europe/Zurich",
            "United States": "America/New_York",  # Par d√©faut, √† ajuster selon la ville
            "Canada": "America/Toronto",
            "Mexico": "America/Mexico_City",
            "Japan": "Asia/Tokyo",
            "China": "Asia/Shanghai",
            "India": "Asia/Kolkata",
            "Australia": "Australia/Sydney",
            "Brazil": "America/Sao_Paulo",
            "Argentina": "America/Argentina/Buenos_Aires",
            "Egypt": "Africa/Cairo",
            "South Africa": "Africa/Johannesburg",
            "Turkey": "Europe/Istanbul",
            "Russia": "Europe/Moscow"  # Simplification
        }
    
    def add_custom_city(self, name: str, country: str, latitude: float, 
                       longitude: float, timezone: str, population: int = 0):
        """Ajoute une ville personnalis√©e"""
        cursor = self.connection.cursor()
        
        cursor.execute('''
            INSERT INTO cities (name, country, latitude, longitude, timezone, population)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (name, country, latitude, longitude, timezone, population))
        
        self.connection.commit()
        print(f"Ville personnalis√©e ajout√©e : {name}, {country}")
    
    def backup_database(self, backup_path: str):
        """Sauvegarde la base de donn√©es"""
        import shutil
        
        # Fermer la connexion actuelle
        if self.connection:
            self.connection.close()
        
        # Copier le fichier
        shutil.copy2(self.db_path, backup_path)
        
        # Rouvrir la connexion
        self.connection = sqlite3.connect(self.db_path, check_same_thread=False)
        self.connection.row_factory = sqlite3.Row
        
        print(f"Base de donn√©es sauvegard√©e : {backup_path}")
    
    def close(self):
        """Ferme la connexion √† la base de donn√©es"""
        if self.connection:
            self.connection.close()


class GeocodingService:
    """Service de g√©ocodage avec cache et gestion des erreurs"""
    
    def __init__(self, atlas: CityAtlas):
        self.atlas = atlas
        self.cache = {}
        self.cache_duration = 3600  # 1 heure en secondes
    
    def geocode(self, query: str, use_online: bool = True) -> Optional[Dict]:
        """
        G√©ocode une requ√™te (ville, pays, adresse)
        
        Args:
            query: Texte √† g√©ocoder
            use_online: Utiliser les services en ligne si la base locale √©choue
            
        Returns:
            Dict avec les informations de localisation ou None
        """
        # V√©rifier le cache
        cache_key = query.lower().strip()
        if cache_key in self.cache:
            cached_result, timestamp = self.cache[cache_key]
            if time.time() - timestamp < self.cache_duration:
                return cached_result
        
        # 1. Essayer la base de donn√©es locale
        local_results = self.atlas.search_cities(query, limit=5)
        
        if local_results:
            # Prendre la meilleure correspondance (ville la plus peupl√©e)
            result = local_results[0]
            geocoded_data = {
                'name': result['name'],
                'country': result['country'],
                'latitude': result['latitude'],
                'longitude': result['longitude'],
                'timezone': result['timezone'],
                'source': 'local',
                'confidence': self._calculate_confidence(query, result['name'])
            }
            
            # Mettre en cache
            self.cache[cache_key] = (geocoded_data, time.time())
            return geocoded_data
        
        # 2. Si √©chec local et online autoris√©, utiliser le service en ligne
        if use_online:
            online_result = self.atlas.search_with_online_service(query)
            if online_result:
                # Mettre en cache
                self.cache[cache_key] = (online_result, time.time())
                return online_result
        
        return None
    
    def _calculate_confidence(self, query: str, city_name: str) -> float:
        """Calcule un score de confiance pour la correspondance"""
        query_lower = query.lower().strip()
        city_lower = city_name.lower().strip()
        
        # Correspondance exacte
        if query_lower == city_lower:
            return 1.0
        
        # Correspondance au d√©but
        if city_lower.startswith(query_lower):
            return 0.9
        
        # Contient la requ√™te
        if query_lower in city_lower:
            return 0.8
        
        # Distance de Levenshtein (approximation)
        distance = self._levenshtein_distance(query_lower, city_lower)
        max_length = max(len(query_lower), len(city_lower))
        similarity = 1 - (distance / max_length)
        
        return max(0.1, similarity)
    
    def _levenshtein_distance(self, s1: str, s2: str) -> int:
        """Calcule la distance de Levenshtein entre deux cha√Ænes"""
        if len(s1) < len(s2):
            return self._levenshtein_distance(s2, s1)
        
        if len(s2) == 0:
            return len(s1)
        
        previous_row = range(len(s2) + 1)
        for i, c1 in enumerate(s1):
            current_row = [i + 1]
            for j, c2 in enumerate(s2):
                insertions = previous_row[j + 1] + 1
                deletions = current_row[j] + 1
                substitutions = previous_row[j] + (c1 != c2)
                current_row.append(min(insertions, deletions, substitutions))
            previous_row = current_row
        
        return previous_row[-1]
    
    def reverse_geocode(self, latitude: float, longitude: float) -> Optional[Dict]:
        """
        Reverse g√©ocodage : trouver le nom de la ville √† partir des coordonn√©es
        
        Args:
            latitude: Latitude
            longitude: Longitude
            
        Returns:
            Dict avec les informations de la ville ou None
        """
        # Utiliser l'atlas pour trouver la ville la plus proche
        city = self.atlas.get_city_by_coordinates(latitude, longitude)
        
        if city:
            return {
                'name': city['name'],
                'country': city['country'],
                'latitude': city['latitude'],
                'longitude': city['longitude'],
                'timezone': city['timezone'],
                'distance': city['distance'],
                'source': 'local'
            }
        
        return None
    
    def get_timezone_suggestions(self, latitude: float, longitude: float) -> List[str]:
        """Retourne des suggestions de fuseaux horaires pour des coordonn√©es"""
        # Obtenir la timezone principale
        main_timezone = self.atlas.get_timezone_for_coordinates(latitude, longitude)
        
        # Ajouter des alternatives courantes
        suggestions = [main_timezone]
        
        # Pour les USA, proposer les timezones principales
        if -125 < longitude < -65 and 25 < latitude < 50:
            us_timezones = [
                "America/New_York",
                "America/Chicago", 
                "America/Denver",
                "America/Los_Angeles",
                "America/Phoenix"
            ]
            suggestions.extend([tz for tz in us_timezones if tz != main_timezone])
        
        # Pour le Canada
        if -140 < longitude < -50 and 45 < latitude < 75:
            ca_timezones = [
                "America/Toronto",
                "America/Vancouver",
                "America/Edmonton",
                "America/Winnipeg",
                "America/Halifax"
            ]
            suggestions.extend([tz for tz in ca_timezones if tz != main_timezone])
        
        return list(set(suggestions))  # Enlever les doublons
    
    def clear_cache(self):
        """Vide le cache de g√©ocodage"""
        self.cache.clear()
        print("Cache de g√©ocodage vid√©")


# Instance globale pour faciliter l'utilisation
_global_atlas = None
_geocoding_service = None


def get_atlas():
    """Retourne l'instance globale de l'atlas"""
    global _global_atlas
    if _global_atlas is None:
        _global_atlas = CityAtlas()
    return _global_atlas


def get_geocoding_service():
    """Retourne l'instance globale du service de g√©ocodage"""
    global _geocoding_service
    if _geocoding_service is None:
        _geocoding_service = GeocodingService(get_atlas())
    return _geocoding_service